<!DOCTYPE html>
<meta charset="utf-8">
<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<script>
  MathJax.Hub.Config({
                      tex2jax: {inlineMath: [['$', '$'], ['\\(','\\)']]},
                      TeX: { equationNumbers: {autoNumber: "AMS"} },
                      "HTML-CSS": { showMathMenu: false,
                                    scale: 90 }
                     });
</script>
<link rel="stylesheet" href="http://examples.gurobi.com/base.css">
<style>

.axis path,
.axis line {
    fill: none;
}

.axis text {
    font-family: sans-serif;
    font-size: 11px;
}

</style>
<body>
  <ul id="nav">
    <li class="current"><a href="#intro">Intro</a></li>
    <li><a href="#problem">Problem</a></li>
    <li><a href="#model">Model</a></li>
    <li><a href="#implementation">Implementation</a></li>
    <li><a href="#demo">Live Demo</a></li>
  </ul>
  <div id="example_container">
    <div class="example_section" id="intro">
      <h1>Production planning</h1>
        <subtitle>with piecewise linear objectives and Gurobi</subtitle>
    </div>
    <p>
      In this example we'll solve a simple production scheduling problem
      and demonstrate the use of piecewise linear objectives in Gurobi.
    </p>

    <p>
      We'll construct a mathematical model of the business problem,
      implement this model in Gurobi's Python interface, and compute and
      visualize an optimal solution.
    </p>

    <p>
      Although your own business may not involve production scheduling, the
      same basic techniques used in this example can be used for many other
      applications.
    </p>

    <div class="example_section" id="problem">
      <h2><a href="#problem" name="problem">Problem Description</a></h2>
      <p>
        Before presenting the example, we briefly review piecewise linear
        functions. Piecewise linear functions can be used to approximate
        arbitrary (nonlinear) functions. As an example, the function
        \[
        \ f(x) = -(x - 2.5)^2 + \sin (kx) + 3
        \]
        and its piecewise linear approximation are shown on the visualization
        below. You can vary number of sample points $n$ and the parameter $k$
        to see how the piecewise linear approximation changes.
      </p>

      <ul>
	<li>
          <label for=nData> $n$ </label>
          <input type="range" min = 3 max = 30 step = 1 id="nData" value="10" oninput="redraw()" class="slider-width">
        </li>
        <li>
          <label for=k> $k$ </label>
          <input type="range" min = 1 max = 5 step = 0.01 id="k" value="2" oninput="redraw()" class="slider-width">
        </li>
      </ul>

      <div id="piecewisedemo">
      </div>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.5/d3.min.js"></script>
        <script>

        //Width and height
        var width = 700;
        var height = 300;
        var padding = 20;
        var rangeX = 5;
        var data = [];
        var fVals = [];
        var n = 100; // Number of points to draw function
        var nData; // Number of sampled points
        var k;

        var svg = d3.select("#piecewisedemo")
                      .append("svg")
                      .attr("width", width)
                      .attr("height", height);

        // Create scale functions
        var xScale = d3.scale.linear()
                             .domain([0, rangeX])
                             .range([padding, width - padding]);

        var yScale = d3.scale.linear()
                             .domain([-5,5])
                             .range([height - padding, padding]);

        // Create axis functions
        var xAxis = d3.svg.axis()
                          .scale(xScale);

        var yAxis = d3.svg.axis()
                          .scale(yScale)
                          .orient("left");

        // Create line function
        var line = d3.svg.line();

        // G objects for axes
        var xG = svg.append("g")
                    .attr("class", "axis")
                    .attr("stroke", "black")
                    .attr("shape-rendering", "crispEdges")
                    .attr("transform", "translate(0," + height/2 + ")")
                    .call(xAxis);

        var yG = svg.append("g")
                    .attr("class", "axis")
                    .attr("stroke", "black")
                    .attr("shape-rendering", "crispEdges")
                    .attr("transform", "translate(" + padding + ",0)")
                    .call(yAxis);

        // G object for sample points
        var pointsG = svg.append("g");

        // G object for function
        var functionG = svg.append("g");
        var graph = line.interpolate("linear")
                         .x(function(d) { return xScale(d[0]); })
                         .y(function(d) { return yScale(d[1]); });

        redraw();

        function f(x, k) {
          return -(x - 2.5)*(x - 2.5) + Math.sin(k*x) + 3;
        }

        function redraw() {
          console.log('redraw');
          nData = parseInt(document.getElementById("nData").value);
          k = parseFloat(document.getElementById("k").value);
          console.log(nData, k);
          data = [];

          for (var i = 0; i < nData + 1; i++) {
            var x = rangeX*i/nData;
            data.push([x, f(x,k)]);
          }

          fVals = [];

          for (var i = 0; i < n + 1; i++) {
            var x = rangeX*i/n;
            fVals.push([x, f(x,k)]);
          }
          console.log('data', data[5]);
          pointsG.selectAll("circle").remove("circle");
          pointsG.selectAll("path").remove("path");

          pointsG.selectAll("circle")
               .data(data)
               .enter()
               .append("circle")
               .attr("cx", function(d) { return xScale(d[0]); })
               .attr("cy", function(d) { return yScale(d[1]); })
               .attr("r", 4)
               .attr("fill", "gray");

          pointsG.append("path").attr("d", graph(data))
                          .attr("fill", "none")
                          .attr("stroke", "gray");

          functionG.selectAll("path").remove("path");

          functionG.append("path").attr("d", graph(fVals))
                          .attr("fill", "none")
                          .attr("stroke", "blue");
        }

        </script>
    </div>

    <p>
      The function $f(x)$ is not convex. But $f(x)$ can still be
      minimized/maximized with Gurobi by invoking <a href="http://www.gurobi.com/documentation/6.0/refman/py_model_setpwlobj.html">
      piecewise linear objectives</a>.
      The problem will be transformed to a MIP and solved. If $f(x)$ is convex,
      the model is transformed to an LP and solved.
    </p>

    <p>
      Piecewise linear objectives also arise naturally in many different
      applications. In this example, we will see how piecewise linear objectives
      are used to solve problems which involve <em>soft constraints</em>.
    </p>

    <p>
      We consider a factory which produces different types of items.
      Each product has a cost and can be produced at a certain rate. The
      goal is then to decide, given the demands for each item, which
      amount of each item to produce to maximize the profit.
    </p>

    <p>
      The amount of work hours is, however, limited. We could add a hard
      constraint on the amount of work hours, for example limit the number
      of work hours in a week to 50. In reality, it is often the case that
      we can go beyond the time limit but only if we pay a penalty cost. So
      if 55 hours of work were done in a week, 50 of those would be at no extra
      cost, while we pay a penalty of 100$/hour on the final 5 hours for
      example. This is a soft constraint, because it can be violated if a
      penalty is payed.
    </p>

    <p>
      Piecewise linear objectives also arise in other contexts, e.g. in
      modelling
      <a href ="http://www.more.ms.unimelb.edu.au/students/operationsresearch/lecturenotes/620362_PiecewiseLinearModels.pdf">
      reversible activites, piecewise linear costs, approximating of nonlinear
      functions...</a>
    </p>

    <div class="example_section" id="model">
      <h2><a href="#model" name="model">Mathematical Model</a></h2>

      <p>
        Let us now describe a mathematical model for our problem.
      </p>

      <p>
        Let $P$ be the set of products the factory produces. With each
        product $i$ we associate
        <ul>
          <li>$r_i$: the rate of production in tonnes per hour. </li>
          <li>$p_i$: the profit per tonne of product. </li>
          <li>$l_i$: the maximum limit of product that can be produced (in tonnes). </li>
        </ul>
      </p>

      <p>
        We let the variable $x_i$ denote the amount of product $i$
        we produce (in units of tonnes). The profit, is then given by
        \[
        \ \text{profit} = \sum_{i \in P} p_i x_i
        \]
      </p>

      <p>
        Since we cannot produce "negative" amounts of product and we cannot
        exceed the maximum limit, we add the constraint
        \[
        \ 0 \leq x_i \leq l_i \quad \forall i \in P
        \]
      </p>

      <p>
        Furthermore, there is a limit of the amount of time the factory can
        run. We denote this by $t_{lim}$. Since $x_i$ tonnes of each product
        $i$ is produced at a rate of $r_i$ tonnes per hour, the total amount
        of work hours is given by
        \[
        \ \text{time} = \sum_{i \in P} \frac{x_i}{a_i}
        \]
      </p>

      <p>
        To impose the time limit we could then add the constraint $time
        \leq t_{lim}$. In reality, however, it is often the case that we can
        run the factory beyond the time limit, i.e. work overtime. Overtime work
        is more expensive, so we introduce a penalty cost $c$ per hour. Therefore,
        if the factory runs for less than $t_{lim}$ hours, we pay no penalty, but
        if it goes beyond, we pay a penalty for the extra hours. This can be
        represented by a piecewise linear function of time:
        \[
        \ f(t) = \left\{\begin{array}{ll}
              0 & \text{if } t \leq t_{lim} \\
              c(t-t_{lim}) & \text{if } t > t_{lim}
             \end{array}\right.
        \]
      </p>
      <aside>Plot of $f(t)$, the piecewise linear penalty function.
      </aside>
      <div id="penaltyfunction"></div>
      <script>
      var width = 700;
      var height = 300;
      var svg = d3.select("#penaltyfunction")
              .append("svg")
              .attr("width", width)
              .attr("height", height);

      var p1 = [.1*width, .8*height];
      var p2 = [.5*width, .8*height];
      var p3 = [.9*width, .2*height];

      svg.append("line").attr("x1", p1[0]).attr("y1", p1[1]).attr("x2", p2[0]).attr("y2", p2[1]);
      svg.append("line").attr("x1", p2[0]).attr("y1", p2[1]).attr("x2", p3[0]).attr("y2", p3[1]);
      svg.selectAll("line").style("stroke", "rgb(0,0,200)").style("stroke-width", 3);
      svg.append("line").attr("x1", p1[0]).attr("y1", 0).attr("x2", p1[0]).attr("y2", height)
         .style("stroke", "black");
      svg.append("line").attr("x1", 0).attr("y1", p1[1]).attr("x2", width).attr("y2", p1[1])
         .style("stroke", "black");
      svg.append("text").attr("x", .05*width).attr("y", .1*height).text("cost");
      svg.append("text").attr("x", .9*width).attr("y", .9*height).text("time");
      svg.selectAll("text").style("fill", "black");
      svg.append("text").attr("x", p2[0]).attr("y", .9*height).text("time limit")
                        .style("fill", "rgb(0,0,200)");
      svg.selectAll("text").attr("text-anchor", "middle");
      </script>
      <p>
        To incorporate the overtime penalty in our model, we introduce a variable $t$
        for time
        \[
        \ t = \sum_{i \in P} \frac{x_i}{a_i}
        \]
        And we update the profit to include overtime costs
        \[
        \ \text{profit} = \sum_{i \in P} p_i x_i - f(t)
        \]
      </p>

      <p>
        Since we may want to limit the hours of overtime, we add a last (hard) constraint
        \[
        \ t \leq t_{max}
        \]
        where $t_{max}$ is the maximum amount of work hours.
      </p>

      <p>
        Finally, our optimization model becomes
        \[
       \begin{array}{ll}
       \text{maximize} & {\displaystyle \sum_{i \in P} p_i x_i - f(t)} \\
       \text{subject to} & {\displaystyle
                            t = \sum_{i \in P} \frac{x_i}{a_i}} \\
                         & 0 \leq x_i \leq l_i \quad \forall i \in P \\
                         & t \leq t_{max}
       \end{array}
       \]
       where the objective is a piecewise linear function.
      </p>
    </div>
    <div class="example_section" id="implementation">
      <h2><a href="#implementation" name="implementation">Implementation</a></h2>
      <p>Below is the full implementation of the model (and the associated data) in
        Gurobi's Python interface:
      </p>
      <examplecode>
# Example data
rate = [50,40]; profit = [25,32]; limit = [1200,920];
limithours = 20; maxhours = 40; penalty = 100;

n = len(rate) # number of products

m = Model()

# Add variables
x = {}

for i in range(n):
    x[i] = m.addVar(ub = limit[i], vtype=GRB.CONTINUOUS, name="x%d" % i)

t = m.addVar(vtype=GRB.CONTINUOUS, name="t")

m.update()

# Add constraints
m.addConstr(t == quicksum( x[j]/rate[j] for j in range(n)))

m.addConstr(t <= maxhours)

# Set objective
m.setObjective( quicksum(profit[i]*x[i] for i in range(n)), GRB.MAXIMIZE)

# Set piecewise linear objective
nPts = 101
ti = []
fi = []
lb = 0
ub = maxhours;

for i in range(nPts):
    ti.append(lb + (ub - lb) * i / (nPts - 1))
    fi.append(-f(ti[i], limithours, penalty))

m.setPWLObj(t, ti, fi)

m.optimize()
      </examplecode>
    </div>
    <div class="example_section" id="demo">
      <h2><a href="#demo" name="demo">Live Demo</a></h2>

      <p> Add demo description </p>

      <div id="demoarea">
      </div>
      <button class="pure-button" onclick="compute()">Compute</button>
      <p>
        <button class="pure-button" onclick="toggle_div()">Gurobi Log</button>
      </p>


      <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.5/d3.min.js"></script>
      <script>
        function toggle_div() {
          var logfile = d3.select('#logfile');
          if (logfile.style("display") === "none") {
            logfile.style("display", "block");
          } else {
            logfile.style("display", "none");
          }
        }
      </script>

      <examplecode id=logfile>
      </examplecode>
    </div>

    <div style="min-height:100px"></div>

<!--[if gt IE 8]><!--><script src="//ajax.googleapis.com/ajax/libs/jquery/2.1.0/jquery.min.js"></script><!--<![endif]-->
<script src="http://davist11.github.io/jQuery-One-Page-Nav/jquery.nav.js"></script>
<script>
  $(document).ready(function() {
  console.log('calling onePageNav');
  $('#nav').onePageNav();
  });
</script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.5/d3.min.js"></script>
<script>

// Hide Log File initially
d3.select('#logfile').style("display", "none");

// Parameters
var width = 800;
var height = 600;
var colors = d3.scale.category20();
var numProds = 3*7;
var circleSize = 20;
var circleHeight = .42*height;
var numFormat = d3.format(',');

// Parameters for penalty function app
var appHeight = .3*height;
var appWidth = 300;

// Initial data
var rate = [];
var profit = [];
var limit = [];

for (var i = 0; i < numProds; i++) {
  rate.push(20 + Math.round(40*Math.random()));
  profit.push(10 + Math.round(20*Math.random()));
  limit.push(300 + Math.round(200*Math.random()));
}

var limithours;
var maxhours = 200;
var penalty;

/*
 *
 * Set up svg and G objects
 *
 */

var svg = d3.select("#demoarea")
              .append("svg")
              .attr("width", width)
              .attr("height", height);

// G object for background
var backgroundG = svg.append("g");

// G object for penalty app
var appG = svg.append("g");

// G object for solution
var solutionG = svg.append("g");

/*
 *
 * Background
 *
 */

backgroundG.append("rect")
           .attr("x",0)
           .attr("y",0)
           .attr("width", width)
           .attr("height", height)
           .attr("fill", "white");

backgroundG.selectAll("circle")
           .data(rate)
           .enter()
           .append("circle")
           .attr("cx", function(d,i) { return ((i % (numProds/3)) + 1)*width/(numProds/3 + 1); })
           .attr("cy", function(d,i) { return Math.floor(i*3/numProds)*height/6 + circleHeight; })
           .attr("r", circleSize)
           .style("fill", function(d,i) { return colors(i % 20); })
           .style("opacity", .1)
           .style("stroke", "black");

backgroundG.selectAll(".rate")
           .data(rate)
           .enter()
           .append("text")
           .attr("x", function(d,i) { return ((i % (numProds/3)) + 1)*width/(numProds/3 + 1); })
           .attr("y", function(d,i) { return Math.floor(i*3/numProds)*height/6 + circleHeight + 1.7*circleSize; })
           .text(function(d) { return d + " T/hr"});

backgroundG.selectAll(".profit")
           .data(profit)
           .enter()
           .append("text")
           .attr("x", function(d,i) { return ((i % (numProds/3)) + 1)*width/(numProds/3 + 1); })
           .attr("y", function(d,i) { return Math.floor(i*3/numProds)*height/6 + circleHeight + 2.2*circleSize; })
           .text(function(d) { return d + " $/T"});

backgroundG.selectAll(".limit")
           .data(limit)
           .enter()
           .append("text")
           .attr("x", function(d,i) { return ((i % (numProds/3)) + 1)*width/(numProds/3 + 1); })
           .attr("y", function(d,i) { return Math.floor(i*3/numProds)*height/6 + circleHeight + 2.7*circleSize; })
           .text(function(d) { return d + " T"});

backgroundG.selectAll("text").attr("text-anchor", "middle")
          .attr("font-size", 10).attr("font-family", "Helvetica Neue");

/*
 *
 * Penalty function app
 *
 */

// Penalty Function description
backgroundG.append("text").attr("x", .02*width).attr("y", .3*appHeight)
           .text("Penalty Cost Function").attr("font-size", 20)
           .attr("font-weight", 600);
backgroundG.append("text").attr("x", .02*width).attr("y", .45*appHeight)
           .text("Drag the points around to");
backgroundG.append("text").attr("x", .02*width).attr("y", .55*appHeight)
           .text("change the shape of the");
backgroundG.append("text").attr("x", .02*width).attr("y", .65*appHeight)
           .text("function.");

// X and y axes
backgroundG.append("line").attr("x1", width/2 - appWidth/2).attr("y1", 1.05*appHeight)
                          .attr("x2", width/2 + appWidth/2).attr("y2", 1.05*appHeight)
                          .style("stroke", "black");
backgroundG.append("line").attr("x1", width/2 - appWidth/2).attr("y1", 1.05*appHeight)
                          .attr("x2", width/2 - appWidth/2).attr("y2", 0.05*appHeight)
                          .style("stroke", "black");
backgroundG.append("text").attr("text-anchor", "middle").attr("y", 1.15*appHeight).attr("x", width/2 - appWidth/2)
                          .text("0 hours").attr("font-size", 12);
backgroundG.append("text").attr("text-anchor", "middle").attr("y", 1.15*appHeight).attr("x", width/2)
                          .text("100 hours").attr("font-size", 12);
backgroundG.append("text").attr("text-anchor", "middle").attr("y", 1.15*appHeight).attr("x", width/2 + appWidth/2)
                          .text("200 hours").attr("font-size", 12);
backgroundG.append("text").attr("text-anchor", "middle").attr("y", .15*appHeight).attr("x", .53*width - appWidth/2)
                          .text("50,000$").attr("font-size", 12);
backgroundG.append("text").attr("text-anchor", "middle").attr("y", .6*appHeight).attr("x", .53*width - appWidth/2)
                          .text("25,000$").attr("font-size", 12);

backgroundG.selectAll("text").attr("font-family", "Helvetica Neue");

// Initial points
var p1 = [width/2, 1.05*appHeight];
var p2 = [width/2 + appWidth/2, .5*appHeight];

// For dragging
var drag = d3.behavior.drag()
             .on("drag", dragmove);

reline();

function reline() {
  appG.selectAll("circle").remove("circle");
  appG.selectAll("line").remove("line");
  appG.append("line").attr("x1", p1[0]).attr("y1", p1[1]).attr("x2", p2[0]).attr("y2", p2[1]);
  appG.append("line").attr("x1", width/2 - appWidth/2).attr("y1", p1[1]).attr("x2", p1[0]).attr("y2", p1[1]);
  appG.selectAll("line").style("stroke", "rgb(0,0,200)").style("stroke-width", 3);
  appG.append("circle").attr("cx", p1[0]).attr("cy", p1[1]).attr("r", 8)
      .attr("id", "point1").call(drag);
  appG.append("circle").attr("cx", p2[0]).attr("cy", p2[1]).attr("r", 8)
      .attr("id", "point2").call(drag);
}

function dragmove(d) {
  if (d3.select(this).attr("id") === "point1") {
    var px = d3.event.x;
    if (px < width/2 - appWidth/2 || px > width/2 + appWidth/2) {
      return;
    } else {
      p1[0] = px;
    }
  } else {
    var py = d3.event.y;
    if (py < .05*appHeight || py > 1.05*appHeight) {
      return;
    } else {
      p2[1] = py;
    }
  }
  reline();
}

/*
 *
 * Optimization
 *
 */

function posPart(x) {
  if (x > 0) {
    return x;
  } else {
    return 0;
  }
}

function compute() {
  limithours = (p1[0] - (width/2 - appWidth/2))*200/appWidth;
  penalty = -(p2[1] - p1[1])/(p2[0] - p1[0])*500;
  console.log('limithours', limithours);
  console.log('penalty', penalty);
  d3.json('/pwlExample.py')
    .header('Content-Type', 'application/json')
    .post(JSON.stringify({'rate': rate, 'profit': profit, 'limit': limit,
                         'hours': [limithours, maxhours, penalty]}), serverResponse);
}

function serverResponse(error, data) {
  console.log('serverResponse');
  console.log('data', data);
  if (!error) {
    if ('solution' in data) {
        // Import solution and put it into correct format
        var sol = data['solution'];
        console.log('solution', sol);
        var solution = sol[0];
        var time = sol[1];
        var gains = sol[2];
        var logMsg = sol[3]; // Log message to display

        console.log('time', time);
        console.log('profit', gains);

        d3.select('#logfile').html(logMsg);

        solutionG.selectAll("circle").remove("circle");
        solutionG.selectAll("circle")
                  .data(solution)
                  .enter()
                  .append("circle")
                  .attr("cx", function(d,i) { return ((i % (numProds/3)) + 1)*width/(numProds/3 + 1); })
                  .attr("cy", function(d,i) { return Math.floor(i*3/numProds)*height/6 + circleHeight; })
                  .style("fill", function(d,i) { return colors(i % 20); })
                  .style("stroke", "black")
                  .attr("r", 0)
                  .transition()
                  .duration(500)
                  .delay(function(d,i) { return i*50; })
                  .attr("r", function(d,i) { return d/limit[i]*circleSize; })

        solutionG.selectAll("text").remove("text");
        solutionG.append("text")
                 .attr("x", .5*width)
                 .attr("y", .94*height)
                 .text("Profit: " + String(numFormat(Math.round(gains*100)/100)) + "$");
        solutionG.append("text")
                 .attr("x", .5*width)
                 .attr("y", .9*height)
                 .text(Math.round(time*10)/10 + " hours of work of which " + posPart(Math.round(10*(time - Math.floor(limithours)))/10) + " were overtime.");
        solutionG.selectAll("text").attr("text-anchor", "middle")
                 .attr("font-size", 20).attr("font-family", "Helvetica Neue");
    }
  }
}

</script>
