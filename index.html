<!DOCTYPE html>
<meta charset="utf-8">
<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<script>
  MathJax.Hub.Config({
                      tex2jax: {inlineMath: [['$', '$'], ['\\(','\\)']]},
                      TeX: { equationNumbers: {autoNumber: "AMS"} },
                      "HTML-CSS": { showMathMenu: false,
                                    scale: 90 }
                     });
</script>
<link rel="stylesheet" href="http://examples.gurobi.com/base.css">
<style>

.axis path,
.axis line {
    fill: none;
}

.axis text {
    font-family: sans-serif;
    font-size: 11px;
}

</style>
<body>
  <ul id="nav">
    <li class="current"><a href="#intro">Intro</a></li>
    <li><a href="#problem">Problem</a></li>
    <li><a href="#model">Model</a></li>
    <li><a href="#implementation">Implementation</a></li>
    <li><a href="#demo">Live Demo</a></li>
  </ul>
  <div id="example_container">
    <div class="example_section" id="intro">
      <h1>Piecewise Linear Objective</h1>
        <subtitle>with integer programming and Gurobi</subtitle>
    </div>
    Explain use of PWL in Gurobi
    Demonstrate with simple application
    <p> Non-convex optimization </p>
    <p>
      In this example we'll solve a simple production planning problem
      and demonstrate the use of piecewise linear (PWL) objectives in Gurobi.
    </p>

    <p>
      We'll construct a mathematical model of the business problem,
      implement this model in Gurobi's Python interface, and compute and
      visualize an optimal solution.
    </p>

    <p>
      REWRITE THIS
      Although your own business may not involve supermarkets, the
      same basic techniques used in this example can be used for many
      other applications in supply chain, logistics and transportation.
    </p>

    <div class="example_section" id="problem">
      <h2><a href="#problem" name="problem">Problem Description</a></h2>
      <p> Below is the function
      \[
      \ f(x) = -(x - 2.5)^2 + \sin (kx) + 3
      \]
      and its piecewise linear approximation.</p>
      <p>
      <label for=nData> Number of sample points </label>
      <input type="range" min = 3 max = 30 step = 1 id="nData" value="10" oninput="redraw()" class="slider-width">
      </p>
      <p>
      <label for=k> k </label>
      <input type="range" min = 1 max = 5 step = 0.01 id="k" value="2" oninput="redraw()" class="slider-width">
      </p>

      <div id="piecewisedemo">
      </div>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.5/d3.min.js"></script>
        <script>

        //Width and height
        var width = 700;
        var height = 300;
        var padding = 20;
        var rangeX = 5;
        var data = [];
        var fVals = [];
        var n = 100; // Number of points to draw function
        var nData; // Number of sampled points
        var k;

        var svg = d3.select("#piecewisedemo")
                      .append("svg")
                      .attr("width", width)
                      .attr("height", height);

        // Create scale functions
        var xScale = d3.scale.linear()
                             .domain([0, rangeX])
                             .range([padding, width - padding]);

        var yScale = d3.scale.linear()
                             .domain([-5,5])
                             .range([height - padding, padding]);

        // Create axis functions
        var xAxis = d3.svg.axis()
                          .scale(xScale);

        var yAxis = d3.svg.axis()
                          .scale(yScale)
                          .orient("left");

        // Create line function
        var line = d3.svg.line();

        // G objects for axes
        var xG = svg.append("g")
                    .attr("class", "axis")
                    .attr("stroke", "black")
                    .attr("shape-rendering", "crispEdges")
                    .attr("transform", "translate(0," + height/2 + ")")
                    .call(xAxis);

        var yG = svg.append("g")
                    .attr("class", "axis")
                    .attr("stroke", "black")
                    .attr("shape-rendering", "crispEdges")
                    .attr("transform", "translate(" + padding + ",0)")
                    .call(yAxis);

        // G object for sample points
        var pointsG = svg.append("g");

        // G object for function
        var functionG = svg.append("g");
        var graph = line.interpolate("linear")
                         .x(function(d) { return xScale(d[0]); })
                         .y(function(d) { return yScale(d[1]); });

        redraw();

        function f(x, k) {
          return -(x - 2.5)*(x - 2.5) + Math.sin(k*x) + 3;
        }

        function redraw() {
          console.log('redraw');
          nData = parseInt(document.getElementById("nData").value);
          k = parseFloat(document.getElementById("k").value);
          console.log(nData, k);
          data = [];

          for (var i = 0; i < nData + 1; i++) {
            var x = rangeX*i/nData;
            data.push([x, f(x,k)]);
          }

          fVals = [];

          for (var i = 0; i < n + 1; i++) {
            var x = rangeX*i/n;
            fVals.push([x, f(x,k)]);
          }
          console.log('data', data[5]);
          pointsG.selectAll("circle").remove("circle");
          pointsG.selectAll("path").remove("path");

          pointsG.selectAll("circle")
               .data(data)
               .enter()
               .append("circle")
               .attr("cx", function(d) { return xScale(d[0]); })
               .attr("cy", function(d) { return yScale(d[1]); })
               .attr("r", 4)
               .attr("fill", "gray");

          pointsG.append("path").attr("d", graph(data))
                          .attr("fill", "none")
                          .attr("stroke", "gray");

          functionG.selectAll("path").remove("path");

          functionG.append("path").attr("d", graph(fVals))
                          .attr("fill", "none")
                          .attr("stroke", "blue");
        }

        </script>
    </div>

    <p>
      Piecewise linear objectives can be used to approximate any
      function (not necessarily quadratic or linear).
    </p>

    <p>
      Piecewise linear objectives also arise naturally in many different
      applications. In this example, we will see how PWL objectives are
      used to solve problems which involve <em>soft constraints</em>.
    </p>

    <p>
      We consider a
    </p>


    <div class="example_section" id="model">
      <h2><a href="#model" name="model">Mathematical Model</a></h2>

      <p>
        Let $P$ be the set of products the factory produces. With each
        product $i$ we associate
        <ul>
          <li>$r_i$: the rate of production in tonnes per hour. </li>
          <li>$p_i$: the profit per tonne of product. </li>
          <li>$l_i$: the maximum limit of product that can be produced (in tonnes). </li>
        </ul>
      </p>

      <p>
        We let the variable $x_i$ denote the amount of product $i$
        we produce (in units of tonnes). The profit, is then given by
        \[
        \ \text{profit} = \sum_{i \in P} p_i x_i
        \]
      </p>

      <p>
        Since we cannot produce "negative" amounts of product and we cannot
        exceed the maximum limit, we add the constraint
        \[
        \ 0 \leq x_i \leq l_i \quad \forall i \in P
        \]
      </p>

      <p>
        Furthermore, there is a limit of the amount of time the factory can
        run. We denote this by $t_{lim}$. Since $x_i$ tonnes of each product
        $i$ is produced at a rate of $r_i$ tonnes per hour, the total amount
        of work hours is given by
        \[
        \ \text{work hours} = \sum_{i \in P} \frac{x_i}{a_i}
        \]
      </p>

      <p>
        To impose the time limit we could then add the constraint $\text{work hours}
        \leq t_{lim}$. In reality, however, it is often the case that we can
        run the factory beyond the time limit, i.e. work overtime. Overtime work
        is more expensive, so we introduce a penalty cost $c$. Therefore, if the
        factory runs for less than $t_{lim}$ hours, we pay no penalty, but if it
        goes beyond, we pay a penalty for the extra hours. This can be represented
        by a piecewise linear function of time:
        \[
        \ f(t) = \left\{\begin{array}{ll}
              0 & \text{if } t \leq t_{lim} \\
              c(t-t_{lim}) & \text{if } t > t_{lim}
             \end{array}\right.
        \]
      </p>
      <aside>Plot of $f(t)$, the piecewise linear penalty function.
      </aside>
      <div id="penaltyfunction"></div>
      <script>
      var width = 700;
      var height = 300;
      var svg = d3.select("#penaltyfunction")
              .append("svg")
              .attr("width", width)
              .attr("height", height);

      var p1 = [.1*width, .8*height];
      var p2 = [.5*width, .8*height];
      var p3 = [.9*width, .2*height];

      svg.append("line").attr("x1", p1[0]).attr("y1", p1[1]).attr("x2", p2[0]).attr("y2", p2[1]);
      svg.append("line").attr("x1", p2[0]).attr("y1", p2[1]).attr("x2", p3[0]).attr("y2", p3[1]);
      svg.selectAll("line").style("stroke", "rgb(0,0,200)").style("stroke-width", 3);
      svg.append("line").attr("x1", p1[0]).attr("y1", 0).attr("x2", p1[0]).attr("y2", height)
         .style("stroke", "black");
      svg.append("line").attr("x1", 0).attr("y1", p1[1]).attr("x2", width).attr("y2", p1[1])
         .style("stroke", "black");
      svg.append("text").attr("x", .05*width).attr("y", .1*height).text("cost");
      svg.append("text").attr("x", .9*width).attr("y", .9*height).text("time");
      svg.selectAll("text").style("fill", "black");
      svg.append("text").attr("x", p2[0]).attr("y", .9*height).text("time limit")
                        .style("fill", "rgb(0,0,200)");
      svg.selectAll("text").attr("text-anchor", "middle");
      </script>
      <p>
        To incorporate the overtime penalty in our model, we introduce a variable $t$
        for time
        \[
        \ t = \sum_{i \in P} \frac{x_i}{a_i}
        \]
        And we update the profit
        \[
        \ \text{profit} = \sum_{i \in P} p_i x_i - f(t)
        \]
      </p>

      <p>
        Since we may want to limit the hours of overtime, we add a last constraint
        \[
        \ t \leq t_{max}
        \]
        where $t_{max}$ is the maximum amount of work hours.
      </p>

      <p>
        Finally, our optimization model becomes
        \[
       \begin{array}{ll}
       \text{maximize} & {\displaystyle \sum_{i \in P} p_i x_i - f(t)} \\
       \text{subject to} & {\displaystyle
                            t = \sum_{i \in P} \frac{x_i}{a_i}} \\
                         & 0 \leq x_i \leq l_i \quad \forall i \in P \\
                         & t \leq t_{max}
       \end{array}
       \]
       where the objective is a piecewise linear function.
      </p>
    </div>
    <div class="example_section" id="implementation">
      <h2><a href="#implementation" name="implementation">Implementation</a></h2>
      <p>Below is the full implementation of the model (and the associated data) in
        Gurobi's Python interface:
      </p>
      <examplecode>
      Gurobi Code
      </examplecode>
    </div>
    <div class="example_section" id="demo">
      <h2><a href="#demo" name="demo">Live Demo</a></h2>

      <div id="demoarea">
      </div>
      <button class="pure-button" onclick="compute()">Compute</button>
      <p>
        <button class="pure-button" onclick="toggle_div()">Gurobi Log</button>
      </p>


      <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.5/d3.min.js"></script>
      <script>
        function toggle_div() {
          var logfile = d3.select('#logfile');
          if (logfile.style("display") === "none") {
            logfile.style("display", "block");
          } else {
            logfile.style("display", "none");
          }
        }
      </script>

      <examplecode id=logfile>
      </examplecode>
    </div>

    <div style="min-height:100px"></div>

<!--[if gt IE 8]><!--><script src="//ajax.googleapis.com/ajax/libs/jquery/2.1.0/jquery.min.js"></script><!--<![endif]-->
<script src="http://davist11.github.io/jQuery-One-Page-Nav/jquery.nav.js"></script>
<script>
  $(document).ready(function() {
  console.log('calling onePageNav');
  $('#nav').onePageNav();
  });
</script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.5/d3.min.js"></script>
<script>

// Hide Log File initially
d3.select('#logfile').style("display", "none");

// Parameters
var width = 800;
var height = 600;
var colors = d3.scale.category20();
var numProds = 3*7;
var circleSize = 20;
var circleHeight = .42*height;
var numFormat = d3.format(',');

// Parameters for penalty function app
var appHeight = .3*height;
var appWidth = 300;

// Initial data
var rate = [];
var profit = [];
var limit = [];

for (var i = 0; i < numProds; i++) {
  rate.push(20 + Math.round(40*Math.random()));
  profit.push(10 + Math.round(20*Math.random()));
  limit.push(300 + Math.round(200*Math.random()));
}

var limithours;
var maxhours = 200;
var penalty;

/*
 *
 * Set up svg and G objects
 *
 */

var svg = d3.select("#demoarea")
              .append("svg")
              .attr("width", width)
              .attr("height", height);

// G object for background
var backgroundG = svg.append("g");

// G object for penalty app
var appG = svg.append("g");

// G object for solution
var solutionG = svg.append("g");

/*
 *
 * Background
 *
 */

backgroundG.append("rect")
           .attr("x",0)
           .attr("y",0)
           .attr("width", width)
           .attr("height", height)
           .attr("fill", "white");

backgroundG.selectAll("circle")
           .data(rate)
           .enter()
           .append("circle")
           .attr("cx", function(d,i) { return ((i % (numProds/3)) + 1)*width/(numProds/3 + 1); })
           .attr("cy", function(d,i) { return Math.floor(i*3/numProds)*height/6 + circleHeight; })
           .attr("r", circleSize)
           .style("fill", function(d,i) { return colors(i % 20); })
           .style("opacity", .1)
           .style("stroke", "black");

backgroundG.selectAll(".rate")
           .data(rate)
           .enter()
           .append("text")
           .attr("x", function(d,i) { return ((i % (numProds/3)) + 1)*width/(numProds/3 + 1); })
           .attr("y", function(d,i) { return Math.floor(i*3/numProds)*height/6 + circleHeight + 1.7*circleSize; })
           .text(function(d) { return d + " T/hr"});

backgroundG.selectAll(".profit")
           .data(profit)
           .enter()
           .append("text")
           .attr("x", function(d,i) { return ((i % (numProds/3)) + 1)*width/(numProds/3 + 1); })
           .attr("y", function(d,i) { return Math.floor(i*3/numProds)*height/6 + circleHeight + 2.2*circleSize; })
           .text(function(d) { return d + " $/hr"});

backgroundG.selectAll(".limit")
           .data(limit)
           .enter()
           .append("text")
           .attr("x", function(d,i) { return ((i % (numProds/3)) + 1)*width/(numProds/3 + 1); })
           .attr("y", function(d,i) { return Math.floor(i*3/numProds)*height/6 + circleHeight + 2.7*circleSize; })
           .text(function(d) { return d + " T"});

backgroundG.selectAll("text").attr("text-anchor", "middle")
          .attr("font-size", 10).attr("font-family", "Helvetica Neue");

/*
 *
 * Penalty function app
 *
 */

// Penalty Function description
backgroundG.append("text").attr("x", .02*width).attr("y", .3*appHeight)
           .text("Penalty Cost Function").attr("font-size", 20)
           .attr("font-weight", 600);
backgroundG.append("text").attr("x", .02*width).attr("y", .45*appHeight)
           .text("Drag the points around to");
backgroundG.append("text").attr("x", .02*width).attr("y", .55*appHeight)
           .text("change the shape of the");
backgroundG.append("text").attr("x", .02*width).attr("y", .65*appHeight)
           .text("function.");

// X and y axes
backgroundG.append("line").attr("x1", width/2 - appWidth/2).attr("y1", 1.05*appHeight)
                          .attr("x2", width/2 + appWidth/2).attr("y2", 1.05*appHeight)
                          .style("stroke", "black");
backgroundG.append("line").attr("x1", width/2 - appWidth/2).attr("y1", 1.05*appHeight)
                          .attr("x2", width/2 - appWidth/2).attr("y2", 0.05*appHeight)
                          .style("stroke", "black");
backgroundG.append("text").attr("text-anchor", "middle").attr("y", 1.15*appHeight).attr("x", width/2 - appWidth/2)
                          .text("0 hours").attr("font-size", 12);
backgroundG.append("text").attr("text-anchor", "middle").attr("y", 1.15*appHeight).attr("x", width/2)
                          .text("100 hours").attr("font-size", 12);
backgroundG.append("text").attr("text-anchor", "middle").attr("y", 1.15*appHeight).attr("x", width/2 + appWidth/2)
                          .text("200 hours").attr("font-size", 12);
backgroundG.append("text").attr("text-anchor", "middle").attr("y", .15*appHeight).attr("x", .53*width - appWidth/2)
                          .text("50,000$").attr("font-size", 12);
backgroundG.append("text").attr("text-anchor", "middle").attr("y", .6*appHeight).attr("x", .53*width - appWidth/2)
                          .text("25,000$").attr("font-size", 12);

backgroundG.selectAll("text").attr("font-family", "Helvetica Neue");

// Initial points
var p1 = [width/2, 1.05*appHeight];
var p2 = [width/2 + appWidth/2, .5*appHeight];

// For dragging
var drag = d3.behavior.drag()
             .on("drag", dragmove);

reline();

function reline() {
  appG.selectAll("circle").remove("circle");
  appG.selectAll("line").remove("line");
  appG.append("line").attr("x1", p1[0]).attr("y1", p1[1]).attr("x2", p2[0]).attr("y2", p2[1]);
  appG.append("line").attr("x1", width/2 - appWidth/2).attr("y1", p1[1]).attr("x2", p1[0]).attr("y2", p1[1]);
  appG.selectAll("line").style("stroke", "rgb(0,0,200)").style("stroke-width", 3);
  appG.append("circle").attr("cx", p1[0]).attr("cy", p1[1]).attr("r", 8)
      .attr("id", "point1").call(drag);
  appG.append("circle").attr("cx", p2[0]).attr("cy", p2[1]).attr("r", 8)
      .attr("id", "point2").call(drag);
}

function dragmove(d) {
  if (d3.select(this).attr("id") === "point1") {
    var px = d3.event.x;
    if (px < width/2 - appWidth/2 || px > width/2 + appWidth/2) {
      return;
    } else {
      p1[0] = px;
    }
  } else {
    var py = d3.event.y;
    if (py < .05*appHeight || py > 1.05*appHeight) {
      return;
    } else {
      p2[1] = py;
    }
  }
  reline();
}

/*
 *
 * Optimization
 *
 */

function posPart(x) {
  if (x > 0) {
    return x;
  } else {
    return 0;
  }
}

function compute() {
  limithours = (p1[0] - (width/2 - appWidth/2))*200/appWidth;
  penalty = -(p2[1] - p1[1])/(p2[0] - p1[0])*500;
  console.log('limithours', limithours);
  console.log('penalty', penalty);
  d3.json('/pwlExample.py')
    .header('Content-Type', 'application/json')
    .post(JSON.stringify({'rate': rate, 'profit': profit, 'limit': limit,
                         'hours': [limithours, maxhours, penalty]}), serverResponse);
}

function serverResponse(error, data) {
  console.log('serverResponse');
  console.log('data', data);
  if (!error) {
    if ('solution' in data) {
        // Import solution and put it into correct format
        var sol = data['solution'];
        console.log('solution', sol);
        var solution = sol[0];
        var time = sol[1];
        var gains = sol[2];
        var logMsg = sol[3]; // Log message to display

        console.log('time', time);
        console.log('profit', gains);

        d3.select('#logfile').html(logMsg);

        solutionG.selectAll("circle").remove("circle");
        solutionG.selectAll("circle")
                  .data(solution)
                  .enter()
                  .append("circle")
                  .attr("cx", function(d,i) { return ((i % (numProds/3)) + 1)*width/(numProds/3 + 1); })
                  .attr("cy", function(d,i) { return Math.floor(i*3/numProds)*height/6 + circleHeight; })
                  .style("fill", function(d,i) { return colors(i % 20); })
                  .style("stroke", "black")
                  .attr("r", 0)
                  .transition()
                  .duration(500)
                  .delay(function(d,i) { return i*50; })
                  .attr("r", function(d,i) { return d/limit[i]*circleSize; })

        solutionG.selectAll("text").remove("text");
        solutionG.append("text")
                 .attr("x", .5*width)
                 .attr("y", .94*height)
                 .text("Profit: " + String(numFormat(Math.round(gains*100)/100)) + "$");
        solutionG.append("text")
                 .attr("x", .5*width)
                 .attr("y", .9*height)
                 .text(Math.round(time*10)/10 + " hours of work of which " + posPart(Math.round(10*(time - Math.floor(limithours)))/10) + " were overtime.");
        solutionG.selectAll("text").attr("text-anchor", "middle")
                 .attr("font-size", 20).attr("font-family", "Helvetica Neue");
    }
  }
}

</script>
